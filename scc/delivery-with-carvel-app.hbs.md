# Use Gitops Delivery with a Carvel App (alpha)

This topic explains how to deliver Carvel `Packages`, created by the Carvel
Package Supply Chains, from a GitOps repository to one or more run clusters
using Carvel App.

## Prerequisites

To use GitOps Delivery with Carvel App, you must complete the following prerequisites:

- You must create a `Workload` that uses the Carvel Package supply chains. For
  information about Carvel Packages, see [Carvel Package Supply
  Chains](./carvel-package-supply-chain.hbs.md). You must have at least one
  Carvel `Package` generated by this `Workload` stored in your GitOps
  repository.
- You must have at least one Run cluster. Run clusters serve as your deployment
  environments. They can either be Tanzu Application Platform clusters, or
  Kubernetes clusters, but they must have kapp-controller and Contour installed.
  See the [Carvel documentation](https://carvel.dev/kapp-controller/) and the
  [Contour documentation](https://projectcontour.io/).
- If you plan to use a build cluster to control the deployment on all of the run
  clusters, you must create a Build cluster that has network access to your run
  clusters. If you intend to deploy directly on the run cluster without using a
  build cluster, a build cluster is only necessary for building the package.

## Set up Run cluster namespaces

Each Run cluster must have a namespace and `ServiceAccount` with the correct permissions to deploy the Carvel `Packages`.

To set up a developer namespace if your Run cluster is also a Tanzu Application Platform cluster, see [Set up developer namespaces to use installed packages](../install-online/set-up-namespaces.hbs.md).

If your Run cluster is not a Tanzu Application Platform cluster, create a namespace and `ServiceAccount` with the following permissions:

```yaml
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: <run-cluster-ns>
  name: app-cr-role
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "create", "update", "delete"]
- apiGroups: [""]
  resources: ["configmaps", "services"]
  verbs: ["get", "list", "create", "update", "delete"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get", "list", "create", "update", "delete"]
```

## Create Carvel PackageInstalls and secrets

For each Carvel `Package` and each Run cluster, you must create a Carvel `PackageInstall` and a `Secret`. The Carvel `PackageInstall` and the `Secret` is stored in your GitOps repository and deployed to Run clusters by the Carvel `App`.

The following example shows GitOps repository structure after completing the procedures in this section:

```console
app.default.tap/
  packages/
    20230321004057.0.0.yaml  # Package
  staging/
    packageinstall.yaml      # PackageInstall
    params.yaml              # Secret
  prod/
    packageinstall.yaml      # PackageInstall
    params.yaml              # Secret
```

1. For each Run cluster, create a `Secret` that has the values for each `Package` parameter. To see the configurable properties of the `Package`, inspect the `Package` CRâ€™s valuesSchema. See [Carvel Package Supply Chains](./carvel-package-supply-chain.hbs.md). Store the `Secret` in your GitOps repository at `<package_name>/<run_cluster>/params.yaml`.

   ```yaml
   ---
   apiVersion: v1
   kind: Secret
   metadata:
     name: app-values
   stringData:
     values.yaml: |
       ---
       replicas: 2
       hostname: app.mycompany.com
   ```

   > **Note** You can skip this step to use the default parameter values.

2. For each Run cluster, create a `PackageInstall`. Reference the `Secret` you created earlier. Store the `PackageInstall` in your GitOps repository at `<package_name>/<run_cluster>/packageinstall.yaml`.

   ```yaml
   ---
   apiVersion: packaging.carvel.dev/v1alpha1
   kind: PackageInstall
   metadata:
     name: app
   spec:
     serviceAccountName: <run-cluster-ns-sa> # ServiceAccount on Run cluster with permissions to deploy Package, see "Set up Run Cluster Namespaces"
     packageRef:
       refName: app.default.tap # name of the Package
       versionSelection:
         constraints: 20230321004057.0.0 # version of the Package
     values:
     - secretRef:
         name: app-values # Secret created in previous step
   ```

   > **Note** To continuously deploy the latest version of your `Package`, set `versionSelection.constraints: >=0.0.0`.

   > **Important** If you skipped creation of the `Secret`, omit the `values` key.

3. Push the newly created `PackageInstalls` and `Secrets` to your GitOps repository.

## Create an App

1. You must give the Build cluster access to the Run clusters. On the Build cluster, for each Run cluster, create a `Secret` containing the Run cluster's kubeconfig:

   ```console
   kubectl create secret generic <run-cluster>-kubeconfig \
       -n <build-cluster-ns> \
       --from-file=value.yaml=<path-to-run-cluster-kubeconfig>
   ```

2. Each Carvel `App` CR must specify either a service account, by using
   `spec.serviceAccountName`, in the same namespace where the App CR is located
   on the Build cluster. Or specify a `Secret` with kubeconfig contents for a
   target destination Run cluster, by using
   `spec.cluster.kubeconfigSecretRef.name`, to explicitly provide the needed
   privileges for managing app resources. The example in this section uses a
   target Run cluster.

3. The [Carvel App](https://carvel.dev/kapp-controller/docs/v0.43.2/app-spec/)
   custom resource represents a collection of Kubernetes resources that
   kapp-controller can fetch and deploy to a cluster. The `App` points at the
   Git repository branch where kapp-controller resources, such as
   `PackageRepository` and `Packages`, are defined. By default, an `App` custom
   resource syncs the cluster with its fetch source every 30 seconds to prevent
   the cluster state from drifting from its source of truth, which is a Git
   repository in this case. Create the following `App` on your Build cluster:

   ```yaml
   ---
   apiVersion: kappctrl.k14s.io/v1alpha1
   kind: App
   metadata:
     name: hello-app-app
     namespace: BUILD-CLUSTER-NS
   spec:
     # specifies that app should be deployed to destination cluster;
     # by default, cluster is same as where this resource resides
     cluster:
       # specifies namespace in destination cluster
       namespace: ns2
       # specifies secret containing kubeconfig
       kubeconfigSecretRef:
         # specifies secret name within app's namespace
         name: cluster1
         # specifies key that contains kubeconfig
         key: value
     fetch:
     - git:
         url: # GitOps repo URL ex: https://github.com/mycompany/my-gitops
         ref: # GitOps repo branchex: origin/main
         subPath: PATH-FOR-PACKAGES # ex: hello-app.dev.tap/packages/
     - git:
         url: # GitOps repo URL ex: https://github.com/mycompany/my-gitops
         ref: # GitOps repo branch ex: origin/main
         subPath: PATH-FOR-PACKAGE-INSTALLS # ex: hello-app.dev.tap/runcluster1
     template:
     - ytt: {}

      deploy:
     - kapp:
         intoNs: DESIRED-NAMESPACE
         rawOptions: ["--dangerous-allow-empty-list-of-resources=true"]
   ```

  Where:

  - `DESIRED-NAMESPACE` is the namespace you want to use with your app.
  - `PATH-FOR-PACKAGE-INSTALLS` is the package install path.
  - `PATH-FOR-PACKAGES` is the package path.
  - `BUILD-CLUSTER-NS` is the build cluster namespace.

   > **Note** The fetch section can includes entries for all the locations in the GitOps repository to deploy, and append with other run clusters if needed.

## Verifying applications

To verify your installation:

1. Target a Run cluster. Confirm that all Packages from the GitOps repository are deployed:

   ```console
   kubectl get packages -A
   ```

2. Target a Run cluster. Confirm that all PackageInstalls are reconciled:

   ```console
   kubectl get packageinstalls -A
   ```

You can access your application on each Run cluster.